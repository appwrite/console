#!/bin/sh

# Regenerate env.js from runtime PUBLIC_ environment variables

echo "Regenerating env.js from environment variables..."

# Build JSON object from PUBLIC_ env vars
env_json="{"
first=true

for var in $(printenv | grep '^PUBLIC_' | awk -F= '{print $1}' | sort); do
    value=$(printenv "$var")
    
    # Escape special characters for JSON
    escaped_value=$(echo "$value" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
    
    if [ "$first" = true ]; then
        first=false
    else
        env_json="$env_json,"
    fi
    
    env_json="$env_json\"$var\":\"$escaped_value\""
    echo "  $var=$value"
done

env_json="$env_json}"

# Write to env.js
# Determine correct path based on script location
if [ -d "./_app" ]; then
    # Script is in build/ directory
    env_file="./_app/env.js"
elif [ -d "./build/_app" ]; then
    # Script is in root or docker/ directory
    env_file="./build/_app/env.js"
else
    echo "⚠ Error: Cannot find _app directory"
    exit 1
fi

echo "export const env=$env_json" > "$env_file"

echo "✓ Generated $env_file"

# Remove compressed versions (they'll be regenerated by nginx if needed)
rm -f "${env_file}.br" "${env_file}.gz"

exec "$@"