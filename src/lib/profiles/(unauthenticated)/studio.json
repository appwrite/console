{
    "history": [
        {
            "breakpoints": [],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 0.25,
            "layerType": "effect",
            "type": "gradient",
            "usesPingPong": false,
            "speed": 0.25,
            "trackMouse": 0,
            "trackAxes": "xy",
            "mouseMomentum": 0,
            "texture": false,
            "animating": false,
            "isMask": 0,
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.0000); fragColor = color; }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
            ],
            "data": { "downSample": 0.5, "depth": false, "uniforms": {}, "isBackground": true },
            "id": "effect"
        },
        {
            "breakpoints": [
                {
                    "name": "Desktop",
                    "max": null,
                    "min": 992,
                    "props": { "scale": 0.88, "frequency": 0.69 }
                },
                {
                    "max": 991,
                    "name": "Tablet",
                    "props": { "frequency": 0.8, "scale": 0.87 },
                    "min": 576
                }
            ],
            "visible": true,
            "aspectRatio": 1,
            "userDownsample": 1,
            "layerType": "effect",
            "type": "custom",
            "usesPingPong": false,
            "texture": false,
            "speed": 0.5,
            "mouseMomentum": 0,
            "animating": true,
            "isMask": 0,
            "customFragmentShaders": [
                "#version 300 es\nprecision highp float;\n\n// Unicorn Studio inputs\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;\n\nuniform vec2 uResolution;   // px\nuniform vec2 uMousePos;     // 0..1\nuniform float uMouseClick;   // 0 or 1\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec2 uPos;\nuniform float uAmount;\nuniform float uScale;\nuniform float uFrequency;\nuniform float uAngle;\nuniform float uAmplitude;\nuniform int uVariant;\n\nuniform float uTime;\n\nout vec4 fragColor;\n\n// ==============================\n// configuration\n// ==============================\n\nconst float DENSITY_MIN   = 6.0;\nconst float DENSITY_MAX   = 80.0;\nconst float CONTRAST_MIN  = 0.6;\nconst float CONTRAST_MAX  = 1.8;\n\nconst float STEP_CELLS_Y  = 1.2;   // small Y offset\nconst float CHANNEL_DELAY = 0.10;   // slight phase lag\n\nconst float MACRO_SCALE   = 0.13;\nconst float MICRO_FREQ    = 1.5;\nconst float MACRO_WEIGHT  = 0.90;\n\nconst float MICRO_SPEED_MIN = 0.02;\nconst float MICRO_SPEED_MAX = 0.06;\nconst float MACRO_SPEED_MIN = 0.006;\nconst float MACRO_SPEED_MAX = 0.018;\n\n// NEW — center “freeze” controls\nconst float CENTER_STABILITY_RADIUS   = 0.35; // radius (0–1)\nconst float CENTER_STABILITY_STRENGTH = 0.7;  // how strong to bias towards max size\n\n// Fresnel-like radial size bias (center + rim larger)\nconst float FRESNEL_CENTER_RADIUS    = 0.01; // where center lobe fades\nconst float FRESNEL_CENTER_SOFTNESS  = 0.01; // width of the center fade\nconst float FRESNEL_CENTER_STRENGTH  = 0.23; // 0..1, how much bigger at center\n\nconst float FRESNEL_RIM_START        = 0.7; // start of rim boost (radius 0..1)\nconst float FRESNEL_RIM_END          = 0.2; // end of rim boost\nconst float FRESNEL_RIM_STRENGTH     = 0.2; // 0..1, how much bigger near edges\n\n\n// ==============================\n// helpers\n// ==============================\nfloat luma(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); }\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\n\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 345.45));\n  p += dot(p, p + 34.345);\n  return fract(p.x * p.y);\n}\n\nfloat noise2(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  float a = hash21(i);\n  float b = hash21(i + vec2(1.0, 0.0));\n  float c = hash21(i + vec2(0.0, 1.0));\n  float d = hash21(i + vec2(1.0, 1.0));\n  vec2  u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat centerMask(vec2 uv, float yyScale) {\n  vec2 g = (uv - 0.5) * vec2(1.0, 1.0 / yyScale);\n  float d = length(g) * 2.0;\n  return smoothstep(0.65, 1.3, d);\n}\n\n// ===================================================\n// Dot function: per-cell, seam-safe, with center bias\n// ===================================================\nfloat dotFromCell(vec2 id, vec2 fu, float val, float noiseAmp, float mouseLocal,float t, float aaWidth, vec2 uv) {\n  // sample modulation once per cell (prevents wobble)\n  vec2 cellCenter = id + vec2(0.5);\n\n  float tmMicro = mix(MICRO_SPEED_MIN, MICRO_SPEED_MAX, clamp(uFrequency, 0.0, 1.0));\n  float tmMacro = mix(MACRO_SPEED_MIN, MACRO_SPEED_MAX, clamp(uFrequency, 0.0, 1.0));\n\n  float nMicro = noise2(cellCenter * MICRO_FREQ + t * tmMicro);\n  float nMacro = noise2(cellCenter * MACRO_SCALE + t * tmMacro);\n  nMacro = mix(nMacro, noise2(cellCenter * (MACRO_SCALE * 1.8) + 11.7 + t * tmMacro), 0.2);\n\n  float n = mix(nMicro, nMacro, MACRO_WEIGHT);\n\n  // Fresnel-like radial bias: larger at center and near edges (rim)\n  vec2 centered = uv - 0.5;\n  centered.x *= uResolution.x / max(uResolution.y, 1.0); // keep circle round on non-square viewports\nfloat rRad = length(centered);\n\nfloat centerFalloff = 1.0 - smoothstep(\n  FRESNEL_CENTER_RADIUS - FRESNEL_CENTER_SOFTNESS,\n  FRESNEL_CENTER_RADIUS + FRESNEL_CENTER_SOFTNESS,\n  rRad\n);\n\nfloat rim = smoothstep(FRESNEL_RIM_START, FRESNEL_RIM_END, rRad);\n\n  // combined Fresnel profile (0..1)\n  float fresnelProfile = clamp(\n    centerFalloff * FRESNEL_CENTER_STRENGTH +\n    rim           * FRESNEL_RIM_STRENGTH,\n    0.0, 1.0\n  );\n\n  // bias modulation toward larger dots where fresnelProfile > 0\n  n = mix(n, 1.0, fresnelProfile);\n\n\n  // final ink radius\n  float ink = 1.0 - val;\n  ink += (n - 0.5) * 2.0 * noiseAmp;\n  ink = clamp(ink, 0.0, 1.0);\n\n  float r = sqrt(2.0) * ink * 0.5;\n  float d = length(fu);\n\n  float fw = aaWidth;\n  return 1.0 - smoothstep(r, r + fw, d);\n}\n\n// ==============================\n// Main\n// ==============================\nvoid main() {\n  vec2 uv  = vTextureCoord;\n  vec4 src = texture(uTexture, uv);\n  vec3 base = src.rgb;\n\n  float density  = mix(DENSITY_MIN, DENSITY_MAX, clamp(uScale,   0.0, 1.0));\n  float contrast = mix(CONTRAST_MIN, CONTRAST_MAX, clamp(uAmount, 0.0, 1.0));\n  float nAmp     = uAmplitude * 0.35;\n  float angle    = uAngle;\n\n  // mouse local effect\n  float distMouse     = distance(uv, uMousePos);\n  float cursorRadius  = 0.12;\n  float cursorFalloff = 1.0 - smoothstep(cursorRadius * 0.5, cursorRadius, distMouse);\n  float mouseLocal    = max(cursorFalloff * (0.35 + 0.65 * uMouseClick), 0.0);\n\n  // subtle center reduction (keeps previous tone balance)\n  float cMask      = centerMask(uv, 0.70);\n  float centerBias = -(1.0 - cMask) * 0.25 * 0.6;\n\n  // grid setup\n  float aspect = uResolution.x / max(uResolution.y, 1.0);\n  vec2 suv = (uv - 0.5);\n  suv.x *= aspect;\n\n  vec2 gridBase = (rot(angle) * suv) * density;\n\n  vec2 offA = vec2(0.0,  STEP_CELLS_Y);\n  vec2 offB = vec2(0.0,  0.0);\n  vec2 offC = vec2(0.0, -STEP_CELLS_Y);\n\n  vec2 gridA = gridBase + offA;\n  vec2 gridB = gridBase + offB;\n  vec2 gridC = gridBase + offC;\n\n  vec2 idA = floor(gridA), fuA = fract(gridA) - 0.5;\n  vec2 idB = floor(gridB), fuB = fract(gridB) - 0.5;\n  vec2 idC = floor(gridC), fuC = fract(gridC) - 0.5;\n\n  vec2 wA = fwidth(gridA);\n  vec2 wB = fwidth(gridB);\n  vec2 wC = fwidth(gridC);\n  float aaA = max(wA.x, wA.y);\n  float aaB = max(wB.x, wB.y);\n  float aaC = max(wC.x, wC.y);\n\n  float tA = uTime + CHANNEL_DELAY;\n  float tB = uTime;\n  float tC = uTime - CHANNEL_DELAY;\n\n  vec3 outCol = vec3(0.0);\n\n  if (uVariant == 0) {\n    vec3 cmy = 1.0 - clamp(base * contrast, 0.0, 1.0);\n\n    float cDot = dotFromCell(idA, fuA, clamp(1.0 - cmy.x - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tA, aaA, uv);\n    float mDot = dotFromCell(idB, fuB, clamp(1.0 - cmy.y - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tB, aaB, uv);\n    float yDot = dotFromCell(idC, fuC, clamp(1.0 - cmy.z - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tC, aaC, uv);\n\n    vec3 paper = vec3(1.0);\n    paper -= vec3(cDot, 0.0, 0.0);\n    paper -= vec3(0.0, mDot, 0.0);\n    paper -= vec3(0.0, 0.0, yDot);\n\n    float overlap = min(min(cDot, mDot), yDot);\n    paper = mix(paper, vec3(0.3), overlap * 0.2);\n\n    outCol = clamp(paper, 0.0, 1.0);\n  }\n  else if (uVariant == 1) {\n    float v = clamp(luma(base) * contrast - centerBias, 0.0, 1.0);\n    float kDot = dotFromCell(idB, fuB, v, nAmp, mouseLocal, tB, aaB, uv);\n    outCol = mix(vec3(1.0), vec3(0.0), kDot);\n  }\n  else {\n    float rDot = dotFromCell(idA, fuA, clamp(base.r * contrast - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tA, aaA, uv);\n    float gDot = dotFromCell(idB, fuB, clamp(base.g * contrast - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tB, aaB, uv);\n    float bDot = dotFromCell(idC, fuC, clamp(base.b * contrast - centerBias, 0.0, 1.0),\n                             nAmp, mouseLocal, tC, aaC, uv);\n\n    vec3 dots = vec3(rDot, gDot, bDot);\n    float overlap = min(min(dots.r, dots.g), dots.b);\n    dots = mix(dots, vec3(1.0), overlap * 0.5);\n    outCol = clamp(dots, 0.0, 1.0);\n  }\n\n  float outA = src.a > 0.0 ? src.a : 1.0;\n  fragColor = vec4(outCol, outA);\n}\n"
            ],
            "customVertexShaders": [
                "#version 300 es\nprecision mediump float;\n\nin vec3 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\n\nout vec2 vTextureCoord;\nout vec3 vVertexPosition;\n\nvoid main() {\n  gl_Position = vec4(aVertexPosition, 1.0);\n  vTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
            ],
            "compiledFragmentShaders": [
                "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution; uniform vec2 uMousePos; uniform float uScale; uniform float uFrequency;uniform float uTime;out vec4 fragColor;const float DENSITY_MIN = 6.0; const float DENSITY_MAX = 80.0; const float CONTRAST_MIN = 0.6; const float CONTRAST_MAX = 1.8;const float STEP_CELLS_Y = 1.2; const float CHANNEL_DELAY = 0.10;const float MACRO_SCALE = 0.13; const float MICRO_FREQ = 1.5; const float MACRO_WEIGHT = 0.90;const float MICRO_SPEED_MIN = 0.02; const float MICRO_SPEED_MAX = 0.06; const float MACRO_SPEED_MIN = 0.006; const float MACRO_SPEED_MAX = 0.018;const float CENTER_STABILITY_RADIUS = 0.35; const float CENTER_STABILITY_STRENGTH = 0.7;const float FRESNEL_CENTER_RADIUS = 0.01; const float FRESNEL_CENTER_SOFTNESS = 0.01; const float FRESNEL_CENTER_STRENGTH = 0.23;const float FRESNEL_RIM_START = 0.7; const float FRESNEL_RIM_END = 0.2; const float FRESNEL_RIM_STRENGTH = 0.2;float luma(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); } mat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }float hash21(vec2 p) { p = fract(p * vec2(123.34, 345.45)); p += dot(p, p + 34.345); return fract(p.x * p.y); }float noise2(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); float a = hash21(i); float b = hash21(i + vec2(1.0, 0.0)); float c = hash21(i + vec2(0.0, 1.0)); float d = hash21(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(mix(a, b, u.x), mix(c, d, u.x), u.y); }float centerMask(vec2 uv, float yyScale) { vec2 g = (uv - 0.5) * vec2(1.0, 1.0 / yyScale); float d = length(g) * 2.0; return smoothstep(0.65, 1.3, d); }float dotFromCell(vec2 id, vec2 fu, float val, float noiseAmp, float mouseLocal,float t, float aaWidth, vec2 uv) { vec2 cellCenter = id + vec2(0.5);float tmMicro = mix(MICRO_SPEED_MIN, MICRO_SPEED_MAX, clamp(uFrequency, 0.0, 1.0)); float tmMacro = mix(MACRO_SPEED_MIN, MACRO_SPEED_MAX, clamp(uFrequency, 0.0, 1.0));float nMicro = noise2(cellCenter * MICRO_FREQ + t * tmMicro); float nMacro = noise2(cellCenter * MACRO_SCALE + t * tmMacro); nMacro = mix(nMacro, noise2(cellCenter * (MACRO_SCALE * 1.8) + 11.7 + t * tmMacro), 0.2);float n = mix(nMicro, nMacro, MACRO_WEIGHT); vec2 centered = uv - 0.5; centered.x *= uResolution.x / max(uResolution.y, 1.0); float rRad = length(centered);float centerFalloff = 1.0 - smoothstep( FRESNEL_CENTER_RADIUS - FRESNEL_CENTER_SOFTNESS, FRESNEL_CENTER_RADIUS + FRESNEL_CENTER_SOFTNESS, rRad );float rim = smoothstep(FRESNEL_RIM_START, FRESNEL_RIM_END, rRad); float fresnelProfile = clamp( centerFalloff * FRESNEL_CENTER_STRENGTH + rim * FRESNEL_RIM_STRENGTH, 0.0, 1.0 ); n = mix(n, 1.0, fresnelProfile); float ink = 1.0 - val; ink += (n - 0.5) * 2.0 * noiseAmp; ink = clamp(ink, 0.0, 1.0);float r = sqrt(2.0) * ink * 0.5; float d = length(fu);float fw = aaWidth; return 1.0 - smoothstep(r, r + fw, d); }void main() { vec2 uv = vTextureCoord; vec4 src = texture(uTexture, uv); vec3 base = src.rgb;float density = mix(DENSITY_MIN, DENSITY_MAX, clamp(uScale, 0.0, 1.0)); float contrast = mix(CONTRAST_MIN, CONTRAST_MAX, clamp(0.0000, 0.0, 1.0)); float nAmp = 0.9300 * 0.35; float angle = 0.0000; float distMouse = distance(uv, uMousePos); float cursorRadius = 0.12; float cursorFalloff = 1.0 - smoothstep(cursorRadius * 0.5, cursorRadius, distMouse); float mouseLocal = max(cursorFalloff * (0.35 + 0.65 * 0.0000), 0.0); float cMask = centerMask(uv, 0.70); float centerBias = -(1.0 - cMask) * 0.25 * 0.6; float aspect = uResolution.x / max(uResolution.y, 1.0); vec2 suv = (uv - 0.5); suv.x *= aspect;vec2 gridBase = (rot(angle) * suv) * density;vec2 offA = vec2(0.0, STEP_CELLS_Y); vec2 offB = vec2(0.0, 0.0); vec2 offC = vec2(0.0, -STEP_CELLS_Y);vec2 gridA = gridBase + offA; vec2 gridB = gridBase + offB; vec2 gridC = gridBase + offC;vec2 idA = floor(gridA), fuA = fract(gridA) - 0.5; vec2 idB = floor(gridB), fuB = fract(gridB) - 0.5; vec2 idC = floor(gridC), fuC = fract(gridC) - 0.5;vec2 wA = fwidth(gridA); vec2 wB = fwidth(gridB); vec2 wC = fwidth(gridC); float aaA = max(wA.x, wA.y); float aaB = max(wB.x, wB.y); float aaC = max(wC.x, wC.y);float tA = uTime + CHANNEL_DELAY; float tB = uTime; float tC = uTime - CHANNEL_DELAY;vec3 outCol = vec3(0.0);if (0 == 0) { vec3 cmy = 1.0 - clamp(base * contrast, 0.0, 1.0);float cDot = dotFromCell(idA, fuA, clamp(1.0 - cmy.x - centerBias, 0.0, 1.0), nAmp, mouseLocal, tA, aaA, uv); float mDot = dotFromCell(idB, fuB, clamp(1.0 - cmy.y - centerBias, 0.0, 1.0), nAmp, mouseLocal, tB, aaB, uv); float yDot = dotFromCell(idC, fuC, clamp(1.0 - cmy.z - centerBias, 0.0, 1.0), nAmp, mouseLocal, tC, aaC, uv);vec3 paper = vec3(1.0); paper -= vec3(cDot, 0.0, 0.0); paper -= vec3(0.0, mDot, 0.0); paper -= vec3(0.0, 0.0, yDot);float overlap = min(min(cDot, mDot), yDot); paper = mix(paper, vec3(0.3), overlap * 0.2);outCol = clamp(paper, 0.0, 1.0); } else if (0 == 1) { float v = clamp(luma(base) * contrast - centerBias, 0.0, 1.0); float kDot = dotFromCell(idB, fuB, v, nAmp, mouseLocal, tB, aaB, uv); outCol = mix(vec3(1.0), vec3(0.0), kDot); } else { float rDot = dotFromCell(idA, fuA, clamp(base.r * contrast - centerBias, 0.0, 1.0), nAmp, mouseLocal, tA, aaA, uv); float gDot = dotFromCell(idB, fuB, clamp(base.g * contrast - centerBias, 0.0, 1.0), nAmp, mouseLocal, tB, aaB, uv); float bDot = dotFromCell(idC, fuC, clamp(base.b * contrast - centerBias, 0.0, 1.0), nAmp, mouseLocal, tC, aaC, uv);vec3 dots = vec3(rDot, gDot, bDot); float overlap = min(min(dots.r, dots.g), dots.b); dots = mix(dots, vec3(1.0), overlap * 0.5); outCol = clamp(dots, 0.0, 1.0); }float outA = src.a > 0.0 ? src.a : 1.0; fragColor = vec4(outCol, outA); }"
            ],
            "compiledVertexShaders": [
                "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = vec4(aVertexPosition, 1.0); vTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy; }"
            ],
            "data": {
                "depth": false,
                "uniforms": {
                    "frequency": { "name": "uFrequency", "type": "1f", "value": 0.5 },
                    "scale": { "name": "uScale", "type": "1f", "value": 0.5 }
                },
                "isBackground": false,
                "heightSegments": 250,
                "widthSegments": 250
            },
            "id": "effect1"
        }
    ],
    "options": {
        "name": "Bg texture simple",
        "fps": 60,
        "dpi": 1.5,
        "scale": 1,
        "includeLogo": false,
        "isProduction": false
    },
    "version": "1.4.36",
    "id": "7dPGShLRLP2pwkYyqA34"
}
